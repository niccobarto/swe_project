\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{geometry}
\usepackage{subcaption}
\geometry{margin=2.5cm}


\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
 \thispagestyle{empty}
 \begin{figure}
     \centering
     \includegraphics[width=0.9\linewidth]{images/unifi.png}
     \label{fig:placeholder}
 \end{figure}
\begin{center}
        \textbf{\Large UNIVERSITÀ DEGLI STUDI DI FIRENZE} \\[0.3cm]
    \textsc{Dipartimento di Ingegneria dell’Informazione} \\[1.5cm]

    % Titolo centrale
    \rule{\textwidth}{0.4pt} \\[0.4cm]
    {\LARGE \textbf{Scriptoria}} \\
    \rule{\textwidth}{0.4pt} \\[3cm]

    % Informazioni in tabella
    \begin{tabular}{p{9cm} p{7cm}}
        \textbf{Autori:} & \textbf{Corso:} \\
        Cristiano Acciai \& Niccolò Bartoli & Ingegneria del software \\[0.8cm]

        \textbf{N° Matricola:} & \textbf{Docente corso:} \\
        7076811 \& 7076612 & Enrico Vicario \end{tabular}
\end{center}
\newpage
\tableofcontents
\newpage

\section{Introduzione}
\subsection{Descrizione del progetto}
Questa relazione ha lo scopo di definire e spiegare i punti chiave relativi alla progettazione di un software Java ideato per la pubblicazione e manutenzione di documenti musicali. L'obiettivo principale è quello di garantire l'affidabilità e autenticità dei documenti per la corretta manutenibilità culturale. Questo tramite moderatori che hanno conoscenza riguardo l'arte con il ruolo di approvare i documenti pubblicati da un Autore; un documento si considera pubblico solo dopo tale conferma. Un utente autenticato potrà quindi visualizzare i documenti pubblici tramite una ricerca legata a vari parametri, aprire il documento, commentarlo o interagirci inserendolo in specifiche collezioni private. Il ruolo dell'admin è quello di un super-utente, che cioè amministra le funzionalità degli utenti e delle funzionalità associate. 
\subsection{Struttura del progetto e ambiente di sviluppo}
Il progetto si compone in diversi package per permettere modularità e singola responsabilità. La suddivisione in livelli consente di ottenere alta modularità, mantenibilità e separazione delle responsabilità. Ogni layer presenta un grado diverso di astrazione, riducendo le dipendenze e facilitando l’evoluzione del software.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/project_structure.png}
    \caption{Architettura del progetto software}
    \label{fig:placeholder}
\end{figure}
I package che troviamo nell'architettura sono i seguenti:
\begin{itemize}
    \item \textbf{Interfaccia}: definisce come l'utente interagisce con il software, permettendo di collegare la rappresentazione grafica alle funzionalità di dominio del software. Non è stata implementata, ma una sua versione semplificata può essere compresa visualizzando i mockup presenti nel prossimo paragrafo.
    \item \textbf{Business Logic}: contiene la logica di business dell'architettura, definendo le funzionalità che ogni tipologia di utente può effettuare nel software. Il package dell'interfaccia invoca questi metodi in seguito ad un evento dell'utente.
    \item \textbf{Domain Model}: le classi contenute in questo package definiscono le entità del software, come i documenti (\texttt{Document}), le richieste di pubblicazione (\texttt{PublishRequest}) o i commenti (\texttt{Comment}).
    \item \textbf{ORM}: questo livello contiene le classi che gestiscono la persistenza degli oggetti del dominio, trasformandoli in record del database. Qui avviene la mappatura tra classi del Domain Model e tabelle, oltre alla definizione delle operazioni di CRUD tramite l'implementazione concreta delle classi DAO.
    \item \textbf{JDBC}: fornisce l'accesso a basso livello al database tramite la definizioni di connessioni con esso. Tali connessioni sono fondamentali per le classi DAO definite nell'ORM permettendo di ottenere i risultati delle query.
    \item \textbf{RDBMS}:rappresenta il sistema che conserva effettivamente i dati con tabelle che rappresentano il nostro dominio, vincoli e relazioni. Nel nostro caso troviamo PostgreSQL come DBMS relazionale scelto.
\end{itemize}

Parlando invece dell'ambiente di sviluppo dell'applicazione, i software utilizzati sono:
\begin{itemize}
    \item \textbf{IntelliJ IDEA}: IDE predefinito per la scrittura del codice Java;
    \item \textbf{StarUML}: creazione di diagrammi UML, use case, modello ER, modello relazionale;
    \item \textbf{PgAdmin}: piattaforma per lo sviluppo e amministrazione di database PostgreSQL;
    \item \textbf{Lunacy}: software di creazione di mockup;
\end{itemize}
\section{Progettazione del software}
\subsection{Attori e casi d'uso}
Il sistema prevede diverse tipologie di attori, ognuna delle quali dispone di funzionalità specifiche coerenti con il proprio ruolo nel dominio applicativo. I casi d’uso descrivono le interazioni tra gli attori e il sistema, specificando obiettivi, vincoli e dipendenze tra funzionalità.

Di seguito sono presentati i tre diagrammi dei casi d’uso, uno per ciascuna categoria di attori principali.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\linewidth]{images/usecase_user.png}
\caption{Casi d’uso dell’Utente / Autore}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\linewidth]{images/usecase_moderator.png}
\caption{Casi d’uso dell’attore Moderatore}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\linewidth]{images/usecase_admin.png}
\caption{Casi d’uso dell’attore Admin}
\end{figure}

\subsubsection{Utente predefinito}
L’utente predefinito è un soggetto autenticato che può accedere alle funzionalità del sistema adibite alla consultazione dei documenti pubblicati e la ricerca filtrata. Può rilasciare commenti sotto uno specifico documento che sarà pubblico a tutti gli altri utenti del sistema, che siano con stesso livello di accesso o moderatori/admin. Può organizzare documenti in collezioni o spuntarli come preferito.
\subsubsection{Autore}
L’Autore è un utente autenticato che può creare, modificare e gestire i propri documenti. Qualsiasi utente ha la possibilità di pubblicare documenti, pertanto Autore viene considerato un tipo specifico di Utente. È la figura centrale nella produzione di contenuti:
può caricare nuovi documenti, etichettarli con tag, organizzarli in collezioni, e soprattutto inviare una richiesta di pubblicazione, che verrà valutata dai Moderatori. Definisce relazioni tra documenti di propria proprietà ed altrui, ovvero collegamenti significativi che definiscono una rete. Gestisce le richieste di relazione che riguardano i propri documenti pubblicati. 

%TABELLA USE CASE 1
\begin{table}[H]
\small
\centering
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textbf{Use Case 1} & \textbf{Creazione documento} \\
\hline
\textbf{Descrizione use case} &
L’utente è in grado di creare documenti di un certo formato caricandone il contenuto. \\
\hline
\textbf{Attori coinvolti} & Utente (Autore) \\
\hline
\textbf{Flusso base} &
\begin{enumerate}
    \item L’utente definisce tutti i parametri necessari alla creazione di un documento nella GUI.
    \item Clicca il pulsante di creazione documento.
    \item Il sistema genera automaticamente i campi \texttt{file\_path} e \texttt{file\_name}, necessari al salvataggio.
    \item La creazione del documento avviene correttamente.
\end{enumerate} \\ 
\hline
\textbf{Flusso alternativo} &
\begin{itemize}
    \item Se i valori passati non rispettano i tipi previsti, viene generata un’eccezione.
\end{itemize} \\
\hline
\textbf{Post-condizioni} &
Ora l’utente possiede un documento associato al proprio profilo come autore.  
Può richiedere la pubblicazione oppure modificarlo. \\
\hline
\end{tabular}
\caption{Template di descrizione del caso d'uso "Creazione documento"}
\end{table}


%TABELLA USE CASE 2
\begin{table}[H]
\centering
\small
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textbf{Use Case 2} & \textbf{Aggiungere tag a documento} \\
\hline
\textbf{Descrizione use case} &
Todo \\
\hline
\textbf{Attori coinvolti} & Utente (Autore) \\
\hline
\textbf{Flusso base} &
\begin{enumerate}
    \item Todo
    \item
    \item
\end{enumerate} \\ 
\hline
\textbf{Flusso alternativo} &
\begin{itemize}
    \item Todo
\end{itemize} \\
\hline
\textbf{Post-condizioni} &
Todo \\
\hline
\end{tabular}
\caption{Template di descrizione del caso d'uso "Aggiunta tag a documento"}
\end{table}

%TABELLA USE CASE 3
\begin{table}[H]
\centering
\small
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textbf{Use Case 3} & \textbf{Creare relazioni tra documenti} \\
\hline
\textbf{Descrizione use case} &
Un autore può definire una relazione tra due documenti pubblicati, scegliendo il tipo di relazione
(e.g. \texttt{NEW\_VERSION\_OF}).  
La relazione diviene visibile a tutti solo dopo l'accettazione da parte dell’autore del documento di destinazione. \\
\hline
\textbf{Attori coinvolti} &
Utente mittente, Utente destinatario \\
\hline
\textbf{Flusso base} &
\begin{enumerate}
    \item L’utente mittente seleziona un proprio documento pubblicato.
    \item Seleziona un secondo documento, che può appartenere a sé stesso oppure a un altro autore.
    \item Sceglie il tipo di relazione da creare e indica quale documento funge da \textit{source} e quale da \textit{destination}.
    \item Il sistema registra la relazione come “in attesa di accettazione”.
    \item L’autore del documento di destinazione visualizza la richiesta di relazione.
    \item L’utente destinatario accetta la relazione, che diviene pubblica e accessibile a tutti gli utenti.
\end{enumerate} \\
\hline
\textbf{Flusso alternativo} &
\begin{itemize}
    \item Se i due documenti appartengono allo stesso autore, la relazione viene pubblicata automaticamente senza alcuna richiesta.
    \item Se l’autore del documento di destinazione non approva la relazione, essa rimane in stato non pubblicato ed eventualmente viene eliminata dal sistema.
    \item Se uno dei documenti non è pubblicato, la relazione non può essere creata.
\end{itemize} \\
\hline
\textbf{Post-condizioni} &
Una volta accettata, la relazione tra i due documenti è visibile a tutti gli utenti
e favorisce la navigazione tra documenti connessi da affinità di contenuto, versione o struttura. \\
\hline
\end{tabular}
\caption{Template di descrizione del caso d'uso "Creare relazioni tra documenti"}
\end{table}


\subsubsection{Moderatore}
Il Moderatore ha il compito di garantire la qualità dei documenti pubblicati. Può visualizzare le richieste di pubblicazione in attesa, analizzare il contenuto del documento e approvarne o rifiutarne la pubblicazione.
È inoltre in grado di consultare lo storico delle richieste già valutate, garantendo tracciabilità delle decisioni.

%TABELLA USE CASE 4
\begin{table}[H]
\centering
\small
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textbf{Use Case 4} & \textbf{Gestire richiesta pubblicazione} \\
\hline
\textbf{Descrizione use case} &
Il moderatore analizza una richiesta di pubblicazione relativa a un documento caricato da un autore,
visualizzandone contenuto e metadati, e decide se approvarla o rifiutarla. \\
\hline
\textbf{Attori coinvolti} &
Moderatore \\
\hline
\textbf{Flusso base} &
\begin{enumerate}
    \item Il moderatore accede alla lista delle richieste di pubblicazione in attesa.
    \item Seleziona una richiesta e visualizza il documento, i suoi metadati e le informazioni fornite dall’autore.
    \item Valuta il contenuto e decide se approvare o rifiutare la richiesta.
    \item In caso di approvazione, il sistema imposta lo stato del documento a \texttt{APPROVED} e lo rende pubblico.
    \item In caso di rifiuto, il sistema imposta lo stato a \texttt{REJECTED} e permette al moderatore di inserire una motivazione.
    \item La richiesta viene marcata come chiusa.
\end{enumerate} \\
\hline
\textbf{Flusso alternativo} &
\begin{itemize}
    \item Se l’utente che tenta la valutazione non è un moderatore (o admin), l’operazione viene bloccata.
    \item Il documento deve trovarsi in stato \texttt{DRAFT} prima della valutazione: in caso contrario la richiesta è invalida.
\end{itemize} \\
\hline
\textbf{Post-condizioni} &
A seconda dell’esito:
\begin{itemize}
    \item Se \texttt{APPROVED}, il documento diventa pubblico e consultabile da tutti gli utenti autenticati.
    \item Se \texttt{REJECTED}, il documento rimane privato e l’autore può modificarlo e inviare una nuova richiesta.
\end{itemize} \\
\hline
\end{tabular}
\caption{Template di descrizione del caso d'uso "Gestire richiesta pubblicazione"}
\end{table}

\subsubsection{Admin}
L’Admin è il super-utente del sistema, con accesso a tutte le funzionalità gestionali.
Può amministrare utenti, documenti, collezioni e commenti, svolgendo funzioni di supervisione e mantenimento dell’integrità del sistema. Sceglie tra gli Utenti chi diventa Moderatore e ne affida le funzionalità di giudice di documenti citati precedentemente. Gli use case dell’Admin includono sia funzionalità correttive (ad esempio eliminazione contenuti) sia funzionalità amministrative (gestione ruoli).

% TABELLA USE CASE 5
\begin{table}[H]
\centering
\small
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\textbf{Use Case 5} & \textbf{Eliminazione di un commento} \\
\hline
\textbf{Descrizione use case} &
L’amministratore può rimuovere un commento pubblicato da un qualsiasi utente qualora risulti
inappropriato, offensivo o non conforme alle linee guida della piattaforma. \\
\hline
\textbf{Attori coinvolti} &
Admin \\
\hline
\textbf{Flusso base} &
\begin{enumerate}
    \item L’admin accede alla lista dei commenti associati ai documenti oppure associati ad uno specifico utente.
    \item Seleziona il commento da eliminare.
    \item Conferma l’operazione di eliminazione.
    \item Il sistema rimuove definitivamente il commento dal database e aggiorna l’interfaccia utente.
\end{enumerate} \\
\hline
\textbf{Flusso alternativo} &
\begin{itemize}
    \item Se il commento non esiste più (già eliminato o riferito a un documento rimosso), il sistema segnala l’errore.
    \item Se l’utente che effettua l’operazione non ha privilegi da admin, l’azione viene bloccata.
\end{itemize} \\
\hline
\textbf{Post-condizioni} &
Il commento selezionato viene eliminato dal sistema, migliorando la qualità dei contenuti pubblici
e mantenendo conforme lo spazio di discussione. \\
\hline
\end{tabular}
\caption{Template di descrizione del caso d'uso "Eliminazione di un commento"}
\end{table}
\subsection{Mockups}
Le seguenti immagini ritraggono i mockup per gli use case considerati negli use case templates riportati precedentemente:
\subsection{Class diagram}
Il diagramma delle classi fornisce una visuale dell’architettura del sistema, descrivendo le principali classi coinvolte, i loro attributi, le funzioni che forniscono e le relazioni che intercorrono tra di esse. Rispetto alla sola suddivisione in package presentata in precedenza, il class diagram consente di evidenziare in modo più preciso le responsabilità di ciascuna classe.

Le classi sono organizzate nei tre package principali:
\begin{itemize}
    \item \textbf{Domain Model}: contiene le entità del dominio applicativo, cioè i concetti con cui si interagisce nell'utilizzo dell'applicazione (ad esempio \texttt{User}, \texttt{Document}, \texttt{Collection}, \texttt{PublishRequest}, \texttt{Comment},\texttt{DocumentSearchCriteria}, \texttt{DocumentSearchCriteriaB\-uilder}) e le relative enumerazioni
    (\texttt{DocumentStatus}, \texttt{DocumentFormat}, \texttt{RequestSt\-atus}, \texttt{DocumentRelationType});
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/domainmodel.png}
        \caption{Domain Model}
    \end{figure}
    \item \textbf{Business Logic}: comprende i controller responsabili dell’implementazione dei casi d’uso (ad esempio \texttt{UserController}, \texttt{AdminController}, \texttt{ModeratorController}, \texttt{RelationController}, \texttt{LoginController}) e che orchestrano le operazioni sulle entità del dominio;
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/businesslogic.png}
        \caption{Business Logic}
    \end{figure}
    \item \textbf{ORM (Object Relation Mapping)}: raccoglie le classi DAO (\texttt{UserDAO}, \texttt{DocumentDAO}, \texttt{PublishRequestDAO}, \texttt{CommentDAO}, \texttt{CollectionDAO}, \texttt{DocumentsRelationDAO}) e le componenti di accesso al database (\texttt{BaseDAO}, \texttt{DBConnection}), incaricate di tradurre le operazioni sul modello a oggetti in query verso il database relazionale.
     \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/orm.png}
        \caption{ORM (Object Relation Mapping)}
    \end{figure}

\end{itemize}

\subsubsection{Design pattern: Singleton}
Considerando che ogni classe DAO presente nel package ORM per funzionare deve ottenere una connessione al database, si vuole definire un meccanismo che permetta di centralizzare questo processo. La classe \texttt{DBConnection} implementa il pattern creazionale \textbf{Signleton}, utilizzato per la garanzia di un'unica istanza di connessione al database.

Il costrurrore della classe è dichiarato \texttt{private}, impedendo la creazione di oggetti tramite il costruttore. L'accesso alla connessione avviene esclusivamente attraverso il metodo \texttt{getConnection()} della classe astratta \texttt{BaseDAO}, estesa da tutte le classi DAO, che istanzia la connessione al database chiamando il metodo statico \texttt{getInstance()} di \texttt{DBConnection}. Tale metodo richiama il costruttore privato solamente al primo utilizzo, ritornando l'istanza appena creata oppure la cui creazione era avvenuta in invocazioni precedenti.



\subsubsection{Design pattern: Mapper}
Prendendo la classe \texttt{Comment} nel \textbf{Domain Model}, non rappresenta di per se un'entità autonoma, ma collegata direttamente al documento a cui è riferita e all'utente autore del commento. Il suo ruolo principale quindi è quello di \textbf{mappare} la relazione tra \texttt{User} e \texttt{Document}, aggiungendo come informazione il testo di tale commento.

Tale design pattern viene chiamato \textbf{Mapper}. Anche alla classe \texttt{DocumentRelation} associamo le stesse caratteristiche, collegando due istanze di \texttt{Document} e includendo il tipo di relazione che c'è nella coppia.
\begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/mapper.png}
        \caption{Mapper}
    \end{figure}
\subsubsection{Design pattern: Builder}

La classe \texttt{DocumentSearchCriteria} è stata introdotta per rappresentare in modo
compatto i possibili filtri di ricerca sui documenti, come il titolo, l'autore, lo stato del documento, il formato, la data di creazione e l’insieme di tag
associati. Poiché è presente un vasto spazio dei parametri possibili e non tutti possono essere utilizzati nella stessa ricerca, è necessario definire un meccanismo che ci distanzi dall'implementazione di numerosi costruttori per considerare ogni possibile gruppo di parametri, un problema denominato \textit{telescoping constructor}.

Per evitare questo problema è stato adottato il pattern \textit{Builder}. La classe
\texttt{DocumentSe\-archCriteriaBuilder} funge da costruttore dedicato: essa espone metodi
che permettono di impostare solo i campi di interesse e, tramite il metodo \texttt{build()},
restituisce un’istanza di \texttt{DocumentSearchCriteria}. In questo modo è
possibile creare criteri di ricerca complessi senza ricorrere a costruttori con lunghi
elenchi di parametri, migliorando la leggibilità del codice e rispettando l'\textit{Open/Closed Principle}. Infatti l'aggiunta di un nuovo parametro di ricerca non richiederà la modifica del codice qui mostrato, ma soltanto l'estensione con l'aggiunta del parametro desiderato e del relativo metodo \texttt{set...()}

Nella pratica, la Business Logic costruisce un oggetto \texttt{DocumentSearchCriteria}
tramite il builder a partire dai filtri selezionati dall’utente, e lo passa ai DAO
responsabili della generazione della query SQL.\\\\


\begin{lstlisting}[language=Java, caption=Codice della classe DocumentSearchCriteriaBuilder]
public class DocumentSearchCriteriaBuilder {
    private String documentTitle;
    private Integer authorId;
    private DocumentFormat format;
    private Date createdAfter;
    private Date createdBefore;
    private List<String> tags;

    public DocumentSearchCriteriaBuilder setDocumentTitle(String documentTitle) {
        this.documentTitle = documentTitle;
        return this;
    }
    public DocumentSearchCriteriaBuilder setAuthorId(Integer authorId) {
        this.authorId = authorId;
        return this;
    }

    public DocumentSearchCriteriaBuilder setFormat(DocumentFormat format) {
        this.format = format;
        return this;
    }
    public DocumentSearchCriteriaBuilder setCreatedAfter(Date createdAfter) {
        this.createdAfter = createdAfter;
        return this;
    }
    public DocumentSearchCriteriaBuilder setCreatedBefore(Date createdBefore) {
        this.createdBefore = createdBefore;
        return this;
    }
    public DocumentSearchCriteriaBuilder setTags(List<String> tags) {
        this.tags = tags;
        return this;
    }

    private DocumentSearchCriteriaBuilder(){}

    public static DocumentSearchCriteriaBuilder getInstance(){
        return new DocumentSearchCriteriaBuilder();
    }

    public DocumentSearchCriteria build() {
        DocumentSearchCriteria criteria = new DocumentSearchCriteria();
        criteria.setDocumentTitle(this.documentTitle);
        criteria.setAuthorId(this.authorId);
        criteria.setFormat(this.format);
        criteria.setCreatedAfter(this.createdAfter);
        criteria.setCreatedBefore(this.createdBefore);
        criteria.setTags(this.tags);
        return criteria;
    }
}
\end{lstlisting}

\subsubsection{Design pattern: DAO}
L’obiettivo del pattern \textit{Data Access Object} (DAO) è separare la logica di accesso ai dati dalla logica di business, incapsulando tutte le operazioni verso il database in classi dedicate. In questo
modo il codice applicativo non dipende da dettagli specifici di SQL, del driver JDBC o della
struttura fisica del database, ma interagisce con un’interfaccia ad oggetti dedicata all'interazione con esso.

Nel progetto ogni entità principale del dominio ha un proprio DAO dedicato, responsabile
delle operazioni di creazione, lettura, aggiornamento e cancellazione (CRUD). Ad esempio:
\texttt{UserDAO} si occupa della persistenza degli oggetti \texttt{User}, \texttt{DocumentDAO}
gestisce gli oggetti \texttt{Document}, \texttt{PublishRequestDAO} le entità \texttt{PublishRequest},
\texttt{CommentDAO} i commenti e così via. Tutte queste classi sono raccolte nel package
\texttt{ORM}, che funge da strato di accesso ai dati dell’architettura.
\subsection{Diagramma ER e Modello Relazionale}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/diagrammaER.png}
        \caption{Diagramma ER}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{images/modellorelazionale.png}
        \caption{Modello relazionale}
    \end{figure}
\section{Implementazione delle classi}
\subsection{Business Logic}
Come definito nelle sezioni precedenti, la Business Logic rappresenta il package che espone
tutte le funzionalità utilizzabili dagli utenti del sistema. Questo livello fornisce un insieme
di controller che mettono a disposizione dell’interfaccia utente i metodi necessari alla
realizzazione dei casi d’uso, orchestrando le classi del Domain Model e delegando le operazioni
di persistenza al package ORM.

\subsubsection{LoginController}
Il \texttt{LoginController} rappresenta il primo punto di contatto tra l’utente e il sistema,
poiché l’accesso alle funzionalità dell’applicazione è subordinato a un processo di
autenticazione. Esso espone le operazioni di \texttt{login} e \texttt{register}, consentendo
all’utente di autenticarsi o di creare un nuovo account. Una volta completata con successo
l’autenticazione, il flusso applicativo viene demandato allo \texttt{UserController}.

\subsubsection{UserController}
Lo \texttt{UserController} espone le funzionalità di base accessibili a qualsiasi utente
autenticato. Tra queste rientrano operazioni come \texttt{createDocument},
\texttt{searchDocuments} e \texttt{writeComment}. Attraverso questo controller l’utente può
creare e gestire collezioni personali, aggiungere documenti alle collezioni, scrivere commenti
sui documenti pubblici e ricercare documenti tramite filtri. Inoltre, qualora l’utente assuma
anche il ruolo di autore, lo \texttt{UserController} consente di accedere alle funzionalità di
creazione e modifica dei documenti, inclusa l’aggiunta di tag e la definizione di relazioni con
altri documenti.

\subsubsection{ModeratorController}
Il \texttt{ModeratorController} raccoglie le funzionalità riservate agli utenti con ruolo di
moderatore. In questo contesto il moderatore può selezionare una richiesta di pubblicazione,
visualizzarne i dettagli e determinarne l’esito, approvandola o rifiutandola. L’accesso a tali
operazioni è protetto da controlli sui permessi, poiché le funzionalità sono disponibili
esclusivamente agli utenti che hanno ottenuto l’abilitazione da parte di un amministratore.

\subsubsection{AdminController}
L’\texttt{AdminController} fornisce le funzionalità di amministrazione globale del sistema.
L’amministratore ha il compito di mantenere uno stato coerente e sicuro dell’applicazione,
potendo eseguire operazioni come il ban di utenti, l’eliminazione di commenti non conformi o la
rimozione di documenti che violano le policy della piattaforma.

\subsubsection{RelationController}
La scelta di includere un controller dedicato ad una specifica funzionalità è definita dalla sua importanza e complessità, staccandolo quindi dai metodi di UserController. L'attributo \texttt{selected} presente nel controller rappresenta il documento selezionato dall'utente per eseguire la prossima azione, che può essere:
\begin{itemize}
    \item ricercare quali relazioni hanno \texttt{selected} come source, specificando eventualmente il tipo di relazione che si cerca;
    \item ricercare quali relazioni hanno \texttt{selected} come destination, specificando eventualmente il tipo di relazione che si cerca;
    \item aggiungere una relazione che veda \texttt{selected} come source:
    \item eliminare una relazione che veda \texttt{selected} come source;
    \item accettare la richiesta di relazione effettuata da un'altro utente, dove \texttt{selected} è la destination della relazione;
\end{itemize}

\subsection{Domain Model}

Il Domain Model rappresenta il nucleo concettuale dell’applicazione e descrive le entità
fondamentali del dominio, le loro proprietà e le relazioni che intercorrono tra di esse.
Le classi di questo package modellano i concetti chiave del sistema di gestione dei documenti
musicali e sono utilizzate dalla Business Logic per implementare i casi d’uso, mentre la loro
persistenza è dipende dal package ORM.

\subsubsection{Document}
La classe \texttt{Document} rappresenta l’entità centrale del dominio applicativo.
Un documento modella un contenuto musicale caricato da un autore ed è caratterizzato da
attributi descrittivi quali il titolo, la descrizione, il formato del file, il periodo
storico di riferimento e la data di creazione. Ogni documento è associato a uno stato
(\texttt{DocumentStatus}) che ne definisce il ciclo di vita, ad esempio bozza, in attesa di
approvazione o pubblicato.

Un documento è sempre associato a un autore, rappresentato da un’istanza della classe
\texttt{User}, ed è inoltre collegabile ad altri documenti tramite relazioni.

\subsubsection{User}
La classe \texttt{User} rappresenta un utente del sistema. Essa contiene le informazioni
necessarie all’identificazione e all’autenticazione, come nome, cognome, email e password,
oltre a flag che indicano il ruolo dell’utente all’interno della piattaforma
(\texttt{is\_moderator}, \texttt{is\_admin}).

Un utente può assumere ruoli differenti: utente standard, autore, moderatore o admin.
Dal punto di vista del dominio, un utente può creare documenti, scrivere commenti, gestire
collezioni personali e interagire con i contenuti pubblicati.

\subsubsection{PublishRequest}
La classe \texttt{PublishRequest} modella il processo di richiesta di pubblicazione di un
documento. Essa rappresenta una richiesta inviata da un autore per rendere pubblico un
documento precedentemente creato. Ogni richiesta è associata a un singolo documento e può
essere gestita da un moderatore.

La richiesta possiede uno stato (\texttt{RequestStatus}) che ne rappresenta l’esito
(\texttt{PENDING}, \texttt{APPROVED}, \texttt{REJECTED}), oltre a informazioni temporali
relative alla data di invio e di valutazione. In caso di rifiuto, è possibile associare
una motivazione testuale. Questa classe consente di mantenere traccia delle decisioni di
moderazione e di separare chiaramente il concetto di documento da quello di pubblicazione.

\subsubsection{Collection}
La classe \texttt{Collection} rappresenta un insieme di documenti creato da un utente
per organizzare e consultare i contenuti in modo strutturato. Ogni collezione è associata a
un singolo utente proprietario, ma può contenere un numero arbitrario di documenti.

Dal punto di vista del dominio, le collezioni permettono agli utenti di classificare i
documenti secondo criteri personali, indipendentemente dallo stato di pubblicazione degli
stessi. La classe espone operazioni per l’aggiunta e la rimozione di documenti, mantenendo
coerente la relazione tra collezioni e documenti.

\subsubsection{Comment}
La classe \texttt{Comment} modella un commento testuale associato a un documento.
Essa funge da mapper tra \texttt{User} e \texttt{Document}, collegando l’utente autore del
commento al documento a cui il commento si riferisce. Oltre ai riferimenti alle entità
coinvolte, il commento contiene il testo inserito dall’utente e la data di creazione.

I commenti permettono l’interazione tra gli utenti e arricchiscono i documenti pubblicati
con osservazioni, note o discussioni. La separazione del commento come entità autonoma
consente una gestione flessibile e una possibile moderazione dei contenuti.

\subsubsection{DocumentRelation}
La classe \texttt{DocumentRelation} rappresenta una relazione semantica tra due documenti.
Ogni relazione collega una coppia di documenti distinguendo un documento sorgente
(\textit{source}) e uno di destinazione (\textit{destination}), ed è caratterizzata da un
tipo di relazione (\texttt{DocumentRelationType}) e da uno stato di conferma.

Un documento può essere in relazione con molti altri documenti, ma per ogni coppia specifica
può esistere al massimo una relazione. Questa scelta progettuale consente di evitare
duplicazioni e di mantenere una rappresentazione chiara dei collegamenti tra documenti, come
ad esempio versioni successive, traduzioni o relazioni tematiche.

\subsubsection{DocumentSearchCriteria e DocumentSearchCriteriaBuilder}
Le classi \texttt{DocumentSearchCriteria} e \texttt{DocumentSearchCriteriaBuilder} sono
utilizzate per modellare i criteri di ricerca dei documenti. \texttt{DocumentSearchCriteria}
rappresenta un oggetto immutabile che raccoglie i possibili filtri applicabili a una ricerca,
come titolo, autore, stato, formato o data di creazione.

La costruzione di tale oggetto avviene tramite il pattern \textit{Builder}, implementato
dalla classe \texttt{DocumentSearchCriteriaBuilder}. Questo approccio evita il problema dei
cosiddetti \textit{telescoping constructors} e permette di impostare in modo chiaro e leggibile
solo i criteri desiderati. La Business Logic utilizza il builder per creare i criteri di
ricerca a partire dall’input dell’utente e li passa ai DAO, che si occupano di tradurli nelle
opportune query verso il database.
\subsubsection{Tag}
TODO
\subsubsection{TagChangeRequest}
TODO
\subsubsection{TagChangeOperation}
TODO
\subsection{ORM}
Il package ORM rappresenta il livello di separazione tra i dati dell'applicazione e il suo dominio. Il suo compito è
quello di tradurre le operazioni eseguite sugli oggetti del Domain Model in interrogazioni
verso il database relazionale e viceversa. Le classi DAO contenute nel package rispondono alle interrogazioni istanziando classi del Domain Model, oppure aggiornando il database in base alle operazioni eseguite dall'utente. Le classi DAO citate precedentemente incapsulano l'utilizzo di JDBC.

\subsubsection{DBConnection}
La classe \texttt{DBConnection} si occupa della gestione della connessione al database ed è
implementata secondo il pattern Singleton. Tale scelta garantisce che l’intera applicazione
utilizzi un unico punto di accesso alla connessione, evitando la creazione incontrollata di
connessioni multiple.

La connessione viene inizializzata solo al primo utilizzo (lazy initialization) e resa
disponibile ai DAO tramite un metodo statico.

La classe implementa un attributo \texttt{enableTesting} che se \texttt{True} all'invocazione del metodo \texttt{getInstance()} restituisce la connessione ad un database parallelo a quello di produzione, adibito a testare le funzionalità del software. In questo modo priviamo il database di produzione di operazioni differenti rispetto al suo utilizzo verso l'utenza.

\subsubsection{BaseDAO}
La classe \texttt{BaseDAO} rappresenta una superclasse astratta comune a tutti i DAO del
progetto. Essa fornisce funzionalità condivise, come l’accesso alla connessione ottenuta
tramite \texttt{DBConnection}, e definisce una base comune per la gestione delle operazioni. Contiene un attributo \texttt{Connection connection} il cui tipo è contenuto nella libreria \texttt{java.sql} e che viene restituito dal metodo \texttt{getConnection()} ereditato da tutte le classi che estendono \texttt{BaseDAO}.

\subsubsection{DocumentDAO}
Il \texttt{DocumentDAO} è responsabile della persistenza degli oggetti \texttt{Document}.
Espone metodi per la creazione, l’aggiornamento, l’eliminazione e il recupero dei documenti
dal database.

Un aspetto rilevante di questo DAO è la gestione delle operazioni di ricerca: il
\texttt{DocumentDAO} riceve un’istanza di \texttt{DocumentSearchCriteria} e costruisce
dinamicamente la query SQL applicando esclusivamente i filtri specificati. In questo modo,
la logica di costruzione delle query rimane confinata nel livello ORM, mentre la Business
Logic si limita a definire i criteri di ricerca desiderati.

Nel codice presente in Listing \ref{addDocument} viene invece mostrato un esempio di interazione tra ORM, database e Domain Model per il metodo di creazione di un documento    .
\begin{lstlisting}[language=Java, caption=Codice del metodo DocumentDAO.addDocument(...),label=addDocument]
public boolean addDocument(User author,
                            String title,
                            String description,
                            String documentPeriod,
                            DocumentFormat documentFormat,
                            String filePath,
                            String fileName,
                            List<String> tags){

        try{
            String query = "INSERT INTO document (file_name,description,status,period,file_format,file_path,author_id,creation_date,title) VALUES(?,?,?,?,?,?,?,?,?)";
            PreparedStatement statement = connection.prepareStatement(query);
            statement.setString(1, fileName);
            statement.setString(2, description);
            statement.setString(3,DocumentStatus.DRAFT.toString());
            statement.setString(4,documentPeriod);
            statement.setString(5,documentFormat.toString());
            statement.setString(6,filePath);
            statement.setInt(7,author.getId());
            statement.setDate(8, java.sql.Date.valueOf(java.time.LocalDate.now()));
            statement.setString(9, title);
            statement.executeUpdate();
            statement.close();
            return true;
        }catch(SQLException e){
            LOGGER.log(Level.SEVERE, "Errore durante addDocument(authorId=" + (author!=null?author.getId():null) + ")", e);
            return false;
        }
    }

\end{lstlisting}
\subsubsection{UserDAO}
Il \texttt{UserDAO} gestisce la persistenza della classe \texttt{User}. Fornisce operazioni
per la creazione di nuovi utenti, la ricerca di utenti esistenti e l’aggiornamento delle
informazioni associate a un profilo.

Questo DAO è utilizzato sia durante le operazioni di autenticazione e registrazione, sia
nelle funzionalità amministrative che richiedono la gestione degli utenti, come la
promozione a moderatore o l’eventuale rimozione di un account. Quando l'utente manipola le proprie collezioni o i propri preferiti il flusso di esecuzione accede a questa classe, che richiama altre classi DAO quando necessario. 

\subsubsection{PublishRequestDAO}
La classe \texttt{PublishRequestDAO} si occupa della gestione delle richieste di pubblicazione
rappresentate dalla classe \texttt{PublishRequest}. Esso fornisce metodi per la creazione
di nuove richieste, il recupero delle richieste in attesa e l’aggiornamento dello stato a
seguito della valutazione da parte di un moderatore.

Grazie a questo DAO, il processo di pubblicazione dei documenti risulta separato dalla
gestione dei documenti stessi, permettendo di mantenere traccia delle decisioni di
moderazione e dello storico delle richieste.
\subsubsection{CollectionDAO}
Il \texttt{CollectionDAO} è responsabile della gestione delle collezioni di documenti.
Gestisce la creazione e la modifica delle collezioni, nonché l’associazione e la
disassociazione dei documenti alle collezioni tramite le opportune tabelle di collegamento.

\subsubsection{CommentDAO}
\texttt{CommentDAO} controlla le funzionalità dei commenti associati ai documenti. Espone
metodi per l’aggiunta di nuovi commenti, il recupero dei commenti relativi a un determinato
documento o a un determinato utente e la loro eventuale rimozione
\subsubsection{DocumentRelationDAO}
Il \texttt{DocumentRelationDAO} si occupa della gestione delle relazioni tra documenti
rappresentate dalla classe \texttt{DocumentRelation}. Fornisce operazioni per la creazione,
la ricerca e la rimozione delle relazioni, nonché per l’aggiornamento del loro stato di
conferma.

Questo DAO garantisce che, per ogni coppia di documenti, possa esistere al massimo una
relazione, in accordo con i vincoli definiti nel modello relazionale. La separazione di
questa logica in un DAO dedicato consente di mantenere chiara e coerente la gestione dei
collegamenti semantici tra i documenti.
\subsubsection{TagDAO}
TODO
\subsubsection{TagChangeRequestDAO}
TODO
\section{Testing}
Per verificare la correttezza del codice e del flusso di esecuzione delle funzionalità, è ragionevole definire delle classi adibite al testing. Tramite la libreria \textbf{JUnit}, sono stati definiti tre livelli di test:
\begin{itemize}
    \item Testing per la \textbf{Business Logic}, dove si verificano i metodi di ogni controller considerando esiti positivi e negativi di ogni funzionalità. 
    \item Testing del \textbf{Domain Model}, ristretto soltanto alla classe \texttt{DocumentSearchCriteriaBuilder} poiché l'unica ad implementare delle funzionalità a livello di dominio differenti da getter e setter.
    \item Testing per l'\textbf{ORM}, dove si interagisce con il database seguendo i metodi delle classi DAO e se ne verifica successivamente lo stato e le tuple aggiunte, rimosse o modificate.
\end{itemize}

Come riportato nella sezione precedente, il database di produzione non subisce nessuna interazione con queste classi. E' il database creato appositamente per il testing a ricevere le query dei metodi.

Per ogni livello di testing verranno riportati degli esempi, per poi mostrare l'esito di tutti tramite immagini.
\subsection{Test Business Logic}

Nel Listing \ref{testbusinessadddocument} troviamo il codice che testa la creazione di un nuovo documento:

\begin{lstlisting}[language=Java, caption=Codice del testing di addDocument() ,label=testbusinessadddocument]
    @Test
    void createDocument() {
        // crea documento con titolo
        controller.createDocument("MyDoc", "desc", "1900-1950", DocumentFormat.PDF, List.of("a", "b"));
        List<Document> docs = documentDAO.getDocumentsByAuthor(currentUser.getId());
        assertFalse(docs.isEmpty());
        assertEquals("MyDoc", docs.get(0).getTitle());

        // incrementa nextFileName
        int prev = currentUser.getNextFileName();
        controller.createDocument("T", "d", "1900", DocumentFormat.PDF, List.of("t"));
        assertEquals(prev + 1, currentUser.getNextFileName());

        // input non validi non devono lanciare eccezioni
        assertDoesNotThrow(() -> controller.createDocument(null, "d", "1900", DocumentFormat.PDF, List.of("t")));
        assertDoesNotThrow(() -> controller.createDocument("Doc", null, "1900", DocumentFormat.PDF, List.of("t")));
        assertDoesNotThrow(() -> controller.createDocument("Doc", "d", null, DocumentFormat.PDF, List.of("t")));
        assertDoesNotThrow(() -> controller.createDocument("Doc", "d", "1900", null, List.of("t")));
    }
\end{lstlisting}

Mentre nel Listing \ref{testbusinessmanagereuqest} è presente il test per l'aggiornamento dello status di una \texttt{PublishRequest} da parte di un moderatore:

\begin{lstlisting}[language=Java, caption=Codice del testing di addDocument() ,label=testbusinessmanagereuqest]
    @Test
    void updateDocumentStatus_positive_and_negative_and_auth() {
        // POSITIVO: crea doc + richiesta pendente, approva tramite moderatorController
        documentDAO.addDocument(normalUser, "P", "d", "2000", DocumentFormat.PDF, "fp", "fn", List.of("t"));
        int docId = documentDAO.getDocumentsByAuthor(normalUser.getId()).get(0).getId();
        publishRequestDAO.addRequest(documentDAO.getDocumentById(docId));

        moderatorController.updateDocumentStatus(docId, RequestStatus.APPROVED);

        // il documento deve essere pubblicato
        Document published = documentDAO.getDocumentById(docId);
        assertNotNull(published);
        assertEquals(DocumentStatus.PUBLISHED, published.getStatus());

        // la richiesta deve risultare APPROVED
        List<PublishRequest> approvedReqs = publishRequestDAO.getRequestsByStatus(RequestStatus.APPROVED);
        assertTrue(approvedReqs.stream().anyMatch(r -> r.getDocument() != null && r.getDocument().getId() == docId));

        // NEGATIVO: documento senza richiesta pendente -> non cambia lo status
        documentDAO.addDocument(normalUser, "NoPending", "d", "2001", DocumentFormat.TXT, "fp", "fn2", List.of("t"));
        int docNoPending = documentDAO.getDocumentsByAuthor(normalUser.getId()).get(0).getId();
        // non aggiungiamo publishRequest
        moderatorController.updateDocumentStatus(docNoPending, RequestStatus.APPROVED);
        Document notChanged = documentDAO.getDocumentById(docNoPending);
        assertNotNull(notChanged);
        assertEquals(DocumentStatus.DRAFT, notChanged.getStatus());

        // AUTH: utente non moderatore prova ad approvare -> non deve cambiare lo stato
        ModeratorController nonMod = new ModeratorController(normalUser);
        // crea doc+request per testare l'accesso negato
        documentDAO.addDocument(normalUser, "AuthTest", "d", "2002", DocumentFormat.PDF, "fp", "fn3", List.of("t"));
        int docAuth = documentDAO.getDocumentsByAuthor(normalUser.getId()).get(0).getId();
        publishRequestDAO.addRequest(documentDAO.getDocumentById(docAuth));
        nonMod.updateDocumentStatus(docAuth, RequestStatus.REJECTED);

        // essendo non moderatore lo status della richiesta rimane PENDING e il documento resta DRAFT
        List<PublishRequest> pending = publishRequestDAO.getRequestsByStatus(RequestStatus.PENDING);
        assertTrue(pending.stream().anyMatch(r -> r.getDocument() != null && r.getDocument().getId() == docAuth));
        assertEquals(DocumentStatus.PENDING, documentDAO.getDocumentById(docAuth).getStatus());
    }
\end{lstlisting}


 \begin{figure}[H]
     \centering
     \includegraphics[width=0.4\linewidth]{images/businesslogictest1.png}
     \label{fig:placeholder}
     \caption{I test di AdminController e RelationController}
 \end{figure}
\begin{figure}[H]
     \centering
     \includegraphics[width=0.4\linewidth]{images/businesslogictest2.png}
     \label{fig:placeholder}
     \caption{I test di UserController, ModeratorController e LoginController}
 \end{figure}
 
\subsection{Test Domain Model}
Come già detto, nel package Domain Model la maggior parte delle classi contiene solo metodi getter e setter. Questo perché in questo layer si depositano solo le funzionalità di dominio, che dipende dalla natura del software e del contesto rappresentato da esso. In questo caso quindi solo \texttt{DocumentSearchCriteriaBuilder} incorpora funzionalità di dominio da dover testare:

\begin{lstlisting}[language=Java, caption=Codice del testing DocumentSearchCriteriaBuilder.build()) ,label=testdomainmodel]
@Test
    // Verifica che, quando si impostano tutti i campi, il criterio risultante contenga
    // i valori corrispondenti e che venga fatta una copia difensiva della lista dei tag.
    void buildAllFields() {
        Date after = new Date(1000L);
        Date before = new Date(2000L);
        List<String> tags = new ArrayList<>(Arrays.asList("tag1", "tag2"));

        DocumentSearchCriteria criteria = DocumentSearchCriteriaBuilder.getInstance()
                .setDocumentTitle("My doc")
                .setAuthorId(5)
                .setFormat(DocumentFormat.PDF)
                .setCreatedAfter(after)
                .setCreatedBefore(before)
                .setTags(tags)
                .build();

        assertTrue(criteria.getDocumentTitle().isPresent());
        assertEquals("My doc", criteria.getDocumentTitle().get());

        assertTrue(criteria.getAuthorId().isPresent());
        assertEquals(5, criteria.getAuthorId().get());

        assertTrue(criteria.getFormat().isPresent());
        assertEquals(DocumentFormat.PDF, criteria.getFormat().get());

        assertTrue(criteria.getCreatedAfter().isPresent());
        assertEquals(after, criteria.getCreatedAfter().get());

        assertTrue(criteria.getCreatedBefore().isPresent());
        assertEquals(before, criteria.getCreatedBefore().get());

        assertTrue(criteria.getTags().isPresent());
        assertEquals(2, criteria.getTags().get().size());
        assertEquals(Arrays.asList("tag1", "tag2"), criteria.getTags().get());

        // ensure defensive copy: modifying original list does not affect criteria
        tags.add("newtag");
        assertEquals(2, criteria.getTags().get().size());
    }

    @Test
    // Verifica che, se non si impostano campi, il criterio restituisca Optionals vuoti
    void buildNoFields() {
        DocumentSearchCriteria criteria = DocumentSearchCriteriaBuilder.getInstance()
                .build();

        assertFalse(criteria.getDocumentTitle().isPresent());
        assertFalse(criteria.getAuthorId().isPresent());
        assertFalse(criteria.getFormat().isPresent());
        assertFalse(criteria.getCreatedAfter().isPresent());
        assertFalse(criteria.getCreatedBefore().isPresent());
        assertFalse(criteria.getTags().isPresent());
    }
\end{lstlisting}

E vengono riportati gli esiti:
\begin{figure}[H]
     \centering
     \includegraphics[width=0.7\linewidth]{images/domainmodeltest.png}
     \label{fig:placeholder}
     \caption{I test di DocumentSearchCriteriaBuilder}
 \end{figure}
\subsection{Test ORM}
Nel Listing \ref{testorm11} è presente il codice di testing per la funzionalità di aggiunta e rimozione di una relazione tra due documenti. Il testing viene fatto a livello di operazione CRUD a database

\begin{lstlisting}[language=Java, caption=Codice del testing  ,label=testorm11]
@Test
    void addAndRemoveDocumentRelation() {
        // ensure no relation
        assertEquals(0, countRelationRows(srcDocId, dstDocId));

        relationDAO.addDocumentRelation(srcDocId, dstDocId, DocumentRelationType.QUOTE, false);
        assertEquals(1, countRelationRows(srcDocId, dstDocId));

        relationDAO.removeDocumentRelation(srcDocId, dstDocId);
        assertEquals(0, countRelationRows(srcDocId, dstDocId));
    }
\end{lstlisting}

Nelle immagini successive vengono mostrati tutti i test ed esiti delle classi del package ORM:

\begin{figure}[H]
     \centering
     \includegraphics[width=0.8\linewidth]{images/testorm1.png}
     \label{fig:placeholder}
     \caption{I test PublishRequestDAO, TagChangeRequestDAO, TagDAO}
 \end{figure}
 \begin{figure}[H]
     \centering
     \includegraphics[width=0.8\linewidth]{images/testorm2.png}
     \label{fig:placeholder}
     \caption{I test di DocumentDAO, CollectionDAO, CommentDAO}
 \end{figure}
 \begin{figure}[H]
     \centering
     \includegraphics[width=0.8\linewidth]{images/testorm3.png}
     \label{fig:placeholder}
     \caption{I test di UserDAO e DocumentRelationDAO}
 \end{figure}
\end{document}
